#include <iostream>
#include <fstream>
#include <string>
#include <stack>

using namespace std;

bool isOperator(char ch);

bool correctSymb(string line, int i = 0, bool InNum = false, bool inSymb = false);  //inNum is true when the  symbol must be num, is false when the current symb must be */-+

bool bracketsAreBalanced(string line);

bool isOperand(char ch);

// here, precedence() function is used to define the precedence to the operator.  
int precedence(char op);

// The eqlOrhigher() function is used to check the higher or equal precedence of the two operators in infix expression. 
bool eqlOrHigher(char operator1, char operator2);

string RPN(string infix); 

double doOperation(double leftOp, double rightOp, char ch);

double calculate(string expression); 


int main()
{
    string line;
    fstream file;
    string postfix_expression;

    file.open("aritmetic_expression.txt", ios::in);

    if (file.is_open()) {
        getline(file,line);
    }
    else {
        cout << "Problem with reading from the file!" << endl;
    }

    file.close();

    if (bracketsAreBalanced(line) && correctSymb(line)) {
          postfix_expression = RPN(line);
          cout << calculate(postfix_expression);
    }
    else {
        cout << "The input data is incorrect!";
    }

    return 0;
}

bool isOperator(char ch) {
    return (ch == '+' || ch == '-' || ch == '*' || ch == '/' || ch == '^');
}

bool correctSymb(string line, int i, bool InNum , bool inSymb) { 
    char ch = line[i];
    if (line[i] == '\0') {
        return InNum;
    }
    if (ch == '(') {
        if (InNum) {
            return false;
        }
        inSymb = false;
        InNum = false;
        return correctSymb(line, ++i, InNum, inSymb);
    }
    if (ch == ')') {
        if (inSymb) {
            return false;
        }
        return correctSymb(line, ++i, InNum, inSymb);
    }
    if (ch >= '0' && ch <= '9') {
        if (i != 0 && line[i - 1] == ' ' && (i - 1) != 0 && InNum) {
            return false;
        }
        InNum = true;
        inSymb = false;
        return correctSymb(line, ++i, InNum, inSymb);
    }
    if (ch == ' ') {
        return correctSymb(line, ++i, InNum, inSymb);
    }
    if (isOperator(ch)) {
        if ((!InNum) && (!inSymb) && ch == '-') {
            inSymb = true;
            InNum = false;
            return correctSymb(line, ++i, InNum, inSymb);
        }
        if (!InNum) {
            return false;
        }
        inSymb = true;
        InNum = false;
        return correctSymb(line, ++i, InNum, inSymb);
    }

}

bool bracketsAreBalanced(string line) {
    int numOfOp = 0; //number of the oppening brackets
    int numOfClos = 0; //number of the closing brackets

    for (size_t i = 0; i < line.size(); i++) {
        if (line[i] == '(') {
            numOfOp++;
        }
        if (line[i] == ')') {
            numOfClos++;
        }
    }

    return numOfClos == numOfOp;
}

bool isOperand(char ch) {
    return (ch >= '0' && ch <= '9');
}

// here, precedence() function is used to define the precedence to the operator.  
int precedence(char op) {
    
    if (op == '+' || op == '-')                   /* it defines the lowest precedence */
        return 1;
    if (op == '*' || op == '/')
        return 2;
    if (op == '^')                                /* exponent operator has the highest precedence */
        return 3;

    return 0;
}

/* The eqlOrhigher() function is used to check the higher or equal precedence of the two operators in infix expression. */
bool eqlOrHigher(char operator1, char operator2) {
    int p1 = precedence(operator1);
    int p2 = precedence(operator2);
    if (p1 == p2) {
        if (operator1 == '^') {
            return false;
        }
        return true;
    }
    return  (p1 > p2 ? true : false);
}

string RPN(string infix) {
    stack <char> st;
    string postfix = "";
    char ch;

    st.push('#');

    for (size_t i = 0; i < infix.length(); i++) {
        
        ch = infix[i];

        if (ch == ' ') {
            continue;
        }
        else if (ch == '(') {
            st.push(ch);
        }
        else if (isOperand(ch)) {
            int j = i + 1;
            postfix += ch;

            while (isOperand(infix[i + 1])) {
                postfix += infix[i + 1];
                i++;
            }
            postfix += ' ';
        }
        else if (isOperator(ch)) {
            bool isNegativeNum = false;
            if (ch == '-') {
                isNegativeNum = true;
                for (int j = i - 1; j >= 0; j--) {
                    if (infix[j] != '(' && infix[j] != ' ') {
                        isNegativeNum = false;
                    }
                    if (infix[j] == '(' && isNegativeNum) {
                        postfix += ch;
                        break;
                    }
                }
                if (isNegativeNum) {
                    continue;
                }
            }
            while (!st.empty() && (st.top() != '#') && eqlOrHigher(st.top(), ch)) {
                postfix += st.top();
                postfix += ' ';
                st.pop();
            }
            st.push(ch);
        }
        else if (ch == ')') {
            while (!st.empty() && st.top() != '(') {
                postfix += st.top();
                postfix += ' ';
                st.pop();
            }
            st.pop();
        }
    }
    while (!st.empty() && st.top() != '#') {
        postfix += st.top();
        postfix += ' ';
        st.pop();
    }

    return postfix;
}

double doOperation(double leftOp, double rightOp, char ch) {
    switch (ch) {
    case '+': return leftOp + rightOp;
    case '-': return leftOp - rightOp;
    case '*': return leftOp * rightOp;
    case '/': return leftOp / rightOp;
    case '^': return pow(leftOp, rightOp);
    }
}

double calculate(string expression) {
    stack <double> stack;

    for (size_t i = 0; i < expression.size(); i++) {
        if (isOperand(expression[i])) {
            double operand = expression[i] - 48.0;
            while (expression[i + 1] != ' ') {
                operand = operand * 10 + (expression[i + 1] - 48.0);
                ++i;
            }
            stack.push(operand);
            continue;
        }
        if (expression[i] == '-' && isOperand(expression[i + 1])) {
            double operand = (expression[i + 1] - 48.0);
            ++i;
            while (expression[i + 1] != ' ') {
                operand = operand * 10 + (expression[i + 1] - 48.0);
                ++i;
            }
            operand *= (-1);
            stack.push(operand);
            continue;
        }
        if (isOperator(expression[i])) {
            double leftOp = 0;
            double rightOp = 0;
            double result = 0;
            rightOp += stack.top();
            stack.pop();
            if ((!stack.empty()) && stack.top() != '#') {
                leftOp += stack.top();
                stack.pop();
            }
            result = doOperation(leftOp, rightOp, expression[i]);
            stack.push(result);
            continue;
        }
    }
    return stack.top();
}
