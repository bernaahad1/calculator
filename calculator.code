#include <iostream>
#include <fstream>
#include <string>
#include <stack>

using namespace std;

bool isOperator(char ch) {
    return (ch == '+' || ch == '-' || ch == '*' || ch == '/' || ch == '^');
}

bool correctSymb(string line, int i = 0, bool InNum = false, bool inSymb = false) {
    char ch = line[i];
    if (line[i] == '\0') {
        return InNum;
    }
    if (ch == '(') {
        if (InNum) {
            return false;
        }
        return correctSymb(line, ++i, InNum, inSymb);
    }
    if (ch == ')') {
        if (inSymb) {
            return false;
        }
        return correctSymb(line, ++i, InNum, inSymb);
    }
    if (ch >= '0' && ch <= '9') {
        if (i != 0 && line[i - 1] == ' ' && (i - 1) != 0 && InNum) {
            return false;
        }
        InNum = true;
        inSymb = false;
       return correctSymb(line, ++i, InNum, inSymb);
    }
    if (isAritmeticSymb(ch)) {
        if (!InNum) {
            return false;
        }
        inSymb = true;
        InNum = false;
        return correctSymb(line, ++i, InNum, inSymb);
    }
    if (ch == ' ') {
        return correctSymb(line, ++i, InNum, inSymb);
    }
}

bool bracketsAreBalanced(string line) {
    int numOfOp = 0; //the oppening brackets
    int numOfClos = 0; //the closing brackets

    for (int i = 0; i < line.size(); i++) {
        if (line[i] == '(') {
            numOfOp++;
        }
        if (line[i] == ')') {
            numOfClos++;
        }
    }
    return numOfClos == numOfOp;
}

bool isOperand(char ch) {
    return (ch >= '0' && ch <= '9');
}

// here, precedence() function is used to define the precedence to the operator.  
int precedence(char op)
{
    if (op == '+' || op == '-')                
        return 1;
    if (op == '*' || op == '/')
        return 2;
    if (op == '^')                                 
        return 3;

    return 0;
 }

 /* The eqlOrhigher() function is used to check the higher or equal precedence of the two operators in infix expression. */
bool eqlOrHigher(char operator1, char operator2){
    int p1 = precedence(operator1);
    int p2 = precedence(operator2);
    if (p1 == p2){
        if (operator1 == '^') {
            return false;
        }
        return true;
    }
    return  (p1 > p2 ? true : false);
}

string RPN(string infix) {
    stack <char> st;
    string postfix = "";
    char ch;

    st.push('#');

    for (int i = 0; i < infix.length(); i++)
    {
        ch = infix[i];

        if (ch == ' ') {
            continue;
        }
        else if (ch == '(') {
            st.push(ch);
        } 
        else if (isOperand(ch)) {
            int j = i + 1;
            postfix += ch;

            while (isOperand(infix[i + 1])) {
                postfix += infix[i + 1];
                i++;
            }
            postfix += ' ';
        }
        else if (isOperator(ch)){
            while (!st.empty() && (st.top() != '#') && eqlOrHigher(st.top(), ch)){
                postfix += st.top();
                postfix += ' ';
                st.pop();
            }
            st.push(ch);
        }
        else if (ch == ')'){
            while (!st.empty() && st.top() != '('){
                postfix += st.top();
                postfix += ' ';
                st.pop();
            }
            st.pop();
        }
    }

    while (!st.empty() && st.top() != '#') {
        postfix += st.top();
        postfix += ' ';
        st.pop();
    }

    return postfix;
}

int main()
{
    string line;
    fstream file;
    string postfix_expression;

    file.open("aritmetic_expression.txt", ios::in);

    if (file.is_open()) {
        getline(file,line);
    }
    else {
        cout << "Problem with reading from the file!" << endl;
    }

    file.close();

    if (bracketsAreBalanced(line) && correctSymb(line)) {
          postfix_expression = RPN(line);
    }
    else {
        cout << "The input data is incorrect!";
    }

    return 0;
}
